#!/bin/sh

# Development environment management tool

# set -x

# Default values (will be overridden after option parsing)
TARGET=${TARGET:-$HOME}
VERBOSE=0

# Files and patterns to exclude from linking
EXCLUDE_PATTERNS=".DS_Store Thumbs.db *.tmp .gitkeep"

# ------------------------------
# Logging functions
# ------------------------------

# Source devlog library for performance
DEVLOG_WIDTH=26
. "$(dirname "$0")/devlog.sh"

# Wrapper functions with custom width
vlog() {
  VERBOSE=$VERBOSE log debug "$@"
}

err() {
  log error "$@"
}

# ------------------------------
# Usage and help
# ------------------------------

usage_options() {
  log "Options:" ""
  log "  -d <dir>" "Dev directory (default: ${DEV_HOME})"
  log "  -t <dir>" "Target directory (default: ${TARGET})"
  log "  -v" "Verbose output"
}

usage() {
  setup_environment
  log "dev" "Development environment management tool"
  log ""
  log "Usage:" "dev [options] <command>"
  log ""
  log "Commands:" ""
  log "  env" "Export configuration for dev environment"
  log "  init" "Initialize dev for zsh"
  log "  update" "Update dev from git and re-link"
  log "  edit" "Edit dev repository in \$EDITOR"
  log "  config <action>" "Manage configuration files (status|link|unlink)"
  log "  host" "Provision and update host system"
  log "  tool [name] [action]" "Manage tool installation"
  log "  script [name] [-- args]" "Run utility script"
  log ""
  usage_options
  log "  -h" "Show help"
}

# ------------------------------
# Environment setup
# ------------------------------

setup_environment() {
  # XDG Base Directory Specification
  # Always derive from TARGET to ensure consistency
  XDG_CONFIG_HOME=${TARGET}/.config
  XDG_DATA_HOME=${TARGET}/.local/share
  XDG_STATE_HOME=${TARGET}/.local/state
  XDG_CACHE_HOME=${TARGET}/.cache
  XDG_BIN_HOME=${TARGET}/.local/bin

  # Dev environment variables
  # DEV_HOME defaults to $HOME-based location unless overridden with -d
  # DEV_CONFIG is for user overrides in the TARGET location
  : ${DEV_HOME:=$HOME/.local/share/dev}
  DEV_CONFIG=${DEV_CONFIG:-${XDG_CONFIG_HOME}/dev}
}

# ------------------------------
# Helper functions
# ------------------------------

check_symlink() {
  # Try `realpath` (works on both macOS and Linux if installed)
  if command -v realpath >/dev/null 2>&1; then
    link_target=$(realpath "$1")
    link_src=$(realpath "$2")
  else
    # Fallback to `readlink` for macOS and Linux
    link_target=$(cd "$(dirname "$1")" && cd "$(dirname "$(readlink "$1")")" && pwd)/$(basename "$(readlink "$1")")
    link_src=$(realpath "$2" 2>/dev/null || echo "$2")
  fi
  if [ "$link_src" = "$link_target" ]; then
    return 0
  else
    return 1
  fi
}

# Check if directory is empty and remove it
remove_empty_dir() {
  if ! [ -d "${1}" ]; then
    vlog "missing" "${1}"
  elif [ -z "$(ls -A "${1}")" ]; then
    log "rm" "${1}"
    rmdir "${1}"
  else
    vlog "not empty" "${1}"
  fi
}

# Sync configuration files from source to target directory
# $1: action (list|link|unlink)
config_sync() {
  source_dir="${DEV_HOME}/config"
  target_dir="${XDG_CONFIG_HOME}"
  action="${1}"

  # Build find command with exclude patterns
  find_cmd="find \"${source_dir}\" -type f"
  for pattern in ${EXCLUDE_PATTERNS}; do
    find_cmd="${find_cmd} -not -name \"${pattern}\""
  done

  eval "${find_cmd}" | sort | while read -r source_file; do
    target_file="${target_dir}/${source_file#${source_dir}/}"
    if [ "${action}" = "list" ]; then
      if [ -L "${target_file}" ]; then
        if check_symlink "${target_file}" "${source_file}"; then
          vlog "ok" "${target_file} -> ${source_file}"
        else
          err "invalid link ${target_file}"
        fi
      elif [ -e "${target_file}" ]; then
        log "conflict" "${target_file} -> ${source_file}"
      else
        log "missing" "${target_file} -> ${source_file}"
      fi
    elif [ "${action}" = "link" ]; then
      if [ -L "${target_file}" ]; then
        if check_symlink "${target_file}" "${source_file}"; then
          vlog "ok" "${target_file} -> ${source_file}"
        else
          err "invalid link ${target_file}"
        fi
        continue
      elif [ -e "${target_file}" ]; then
        log "conflict" "${target_file} -> ${source_file}"
        continue
      fi
      mkdir -p "$(dirname "${target_file}")"
      ln -sf "${source_file}" "${target_file}"
      log "link" "${target_file} -> ${source_file}"
    elif [ "${action}" = "unlink" ]; then
      if [ -L "${target_file}" ]; then
        rm "${target_file}"
        log "unlink" "${target_file} -> ${source_file}"
      fi
    fi
  done

  # Clean up empty directories after unlinking (iteratively remove from deepest to shallowest)
  if [ "${action}" = "unlink" ]; then
    while true; do
      empty_dirs=$(find "${target_dir}" -type d -empty 2>/dev/null)
      [ -z "$empty_dirs" ] && break
      echo "$empty_dirs" | while read -r empty_dir; do
        if [ -d "${empty_dir}" ]; then
          rmdir "${empty_dir}" 2>/dev/null && log "rm" "${empty_dir}"
        fi
      done
    done
  fi
}

# ------------------------------
# Command functions (stubs)
# ------------------------------

cmd_env() {
  printf 'export XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}\n'
  printf 'export XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}\n'
  printf 'export XDG_STATE_HOME=${XDG_STATE_HOME:-$HOME/.local/state}\n'
  printf 'export XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}\n'
  printf 'export XDG_BIN_HOME=${XDG_BIN_HOME:-$HOME/.local/bin}\n'
  printf 'export DEV_HOME=${DEV_HOME:-$XDG_DATA_HOME/dev}\n'
  printf 'export DEV_CONFIG=${DEV_CONFIG:-$XDG_CONFIG_HOME/dev}\n'
  printf 'export ZDOTDIR=${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}\n'
  printf 'export PATH=${XDG_BIN_HOME}:${DEV_HOME}/bin:$PATH\n'
}

cmd_init() {
  zshenv="${TARGET}/.zshenv"
  bootstrap_line="eval \"\$(${DEV_HOME}/bin/dev env)\""

  # Check if already initialized
  if [ -f "$zshenv" ] && grep -qF "$bootstrap_line" "$zshenv"; then
    log "init" "Already initialized in $zshenv"
    return 0
  fi

  # Add leading newline if file exists
  [ -f "$zshenv" ] && printf "\n" >>"$zshenv"

  # Append bootstrap
  printf "# dev - Development environment management\n%s\n" "$bootstrap_line" >>"$zshenv"

  log "init" "Initialized dev for zsh"
  log "" "Restart your shell or run: source ~/.zshenv"
}

config_usage() {
  log "dev config" "Manage configuration files"
  log ""
  log "Usage:" "dev [options] config <action>"
  log ""
  log "Actions:" ""
  log "  status" "Show configuration status"
  log "  link" "Link configuration files"
  log "  unlink" "Unlink configuration files"
  log ""
  usage_options
}

cmd_config() {
  action="$1"
  case "$action" in
  status)
    VERBOSE=1
    config_sync "list"
    ;;
  link)
    config_sync "link"
    ;;
  unlink)
    config_sync "unlink"
    ;;
  *)
    if [ -n "$action" ]; then
      err "config: unknown action '$action'"
      log ""
    fi
    config_usage
    exit 1
    ;;
  esac
}

cmd_update() {
  log "update" "Update dev from git and re-link"
  # TODO: Implement update
}

cmd_edit() {
  if [ -z "${EDITOR:-}" ]; then
    err "EDITOR not set"
    exit 1
  fi

  if [ ! -d "$DEV_HOME" ]; then
    err "DEV_HOME not found: $DEV_HOME"
    exit 1
  fi

  vlog "edit" "Opening $DEV_HOME in $EDITOR"
  ${EDITOR} ${DEV_HOME}
}

get_platform_id() {
  case "$(uname -s)" in
  Darwin)
    echo "macos"
    ;;
  Linux)
    if [ -f /etc/os-release ]; then
      . /etc/os-release
      echo "${ID}"
    else
      echo "linux-unknown"
    fi
    ;;
  *)
    echo "unknown"
    ;;
  esac
}

host_usage() {
  log "dev host" "Provision and update host system"
  log ""
  log "Usage:" "dev [options] host"
  log ""
  log "Runs idempotent provisioning for the current platform."
  log "Installs missing packages and updates existing ones."
  log ""
  log "Platform is auto-detected from the system"
  log ""
  usage_options
}

cmd_host() {
  # Check for help
  case "${1:-}" in
  -h | --help)
    host_usage
    return 0
    ;;
  esac

  # Auto-detect platform
  platform=$(get_platform_id)
  host_script="${DEV_HOME}/hosts/${platform}.sh"

  if [ ! -f "$host_script" ]; then
    err "No host script found for platform: $platform"
    exit 1
  fi

  if [ ! -x "$host_script" ]; then
    err "Host script not executable: $host_script"
    exit 1
  fi

  log "host" "Running ${platform} provisioning"
  "${host_script}"
}

tool_usage() {
  log "dev tool" "Manage development tools"
  log ""
  log "Usage:" "dev [options] tool <name> [action]"
  log ""
  log "Actions:" ""
  log "  install" "Install the tool"
  log "  uninstall" "Uninstall the tool"
  log "  update" "Update the tool"
  log "  status" "Show tool status (default)"
  log "  setup" "Configure the tool (for config-only tools)"
  log ""
  log "If no action specified, shows status"
  log ""
  usage_options
}

cmd_tool() {
  tool_name="${1:-}"
  action="${2:-status}"

  # Check for help
  case "${tool_name}" in
  -h | --help | "")
    if [ -z "$tool_name" ]; then
      # List available tools
      log "tool" "Available tools:"
      log ""
      for tool in "${DEV_HOME}/tools"/*.sh; do
        [ -f "$tool" ] && log "  $(basename "$tool" .sh)"
      done
      log ""
      tool_usage
    else
      tool_usage
    fi
    return 0
    ;;
  esac

  tool_script="${DEV_HOME}/tools/${tool_name}.sh"

  if [ ! -f "$tool_script" ]; then
    err "No tool found: $tool_name"
    log ""
    log "Available tools:"
    for tool in "${DEV_HOME}/tools"/*.sh; do
      [ -f "$tool" ] && log "  $(basename "$tool" .sh)"
    done
    exit 1
  fi

  if [ ! -x "$tool_script" ]; then
    err "Tool script not executable: $tool_script"
    exit 1
  fi

  vlog "tool" "Running ${tool_name} ${action}"
  "${tool_script}" "${action}"
}

script_usage() {
  log "dev script" "Run utility scripts"
  log ""
  log "Usage:" "dev [options] script [name] [-- args]"
  log ""
  log "If no name specified, lists available scripts"
  log "Use -- to separate script name from script arguments"
  log ""
  log "Example:" "dev script gitconfig"
  log "Example:" "dev script gpg-backup -- /path/to/backup"
  log ""
  usage_options
}

cmd_script() {
  script_name="${1:-}"

  # Check for help
  case "${script_name}" in
  -h | --help | "")
    if [ -z "$script_name" ]; then
      # List available scripts
      log "script" "Available scripts:"
      log ""
      for script in "${DEV_HOME}/scripts"/*.sh; do
        [ -f "$script" ] && log "  $(basename "$script" .sh)"
      done
      log ""
      script_usage
    else
      script_usage
    fi
    return 0
    ;;
  esac

  # Parse arguments to find -- separator
  script_args=""
  found_separator=0
  shift # Remove script name

  for arg in "$@"; do
    if [ "$arg" = "--" ]; then
      found_separator=1
      continue
    fi

    if [ $found_separator -eq 1 ]; then
      script_args="$script_args $arg"
    fi
  done

  script_path="${DEV_HOME}/scripts/${script_name}.sh"

  if [ ! -f "$script_path" ]; then
    err "No script found: $script_name"
    log ""
    log "Available scripts:"
    for script in "${DEV_HOME}/scripts"/*.sh; do
      [ -f "$script" ] && log "  $(basename "$script" .sh)"
    done
    exit 1
  fi

  if [ ! -x "$script_path" ]; then
    err "Script not executable: $script_path"
    exit 1
  fi

  vlog "script" "Running ${script_name}"
  sh "${script_path}" $script_args
}

# ------------------------------
# Main
# ------------------------------

# Parse command line options
while getopts ":d:t:vh" opt; do
  case $opt in
  d) DEV_HOME=$OPTARG ;;
  t) TARGET=$OPTARG ;;
  v) VERBOSE=1 ;;
  h | \?) usage && exit 0 ;;
  esac
done
shift $((OPTIND - 1))

# Setup environment variables based on TARGET
setup_environment

# Get command
command="${1:-}"
shift 2>/dev/null || true

# Execute command
case "$command" in
env)
  cmd_env "$@"
  ;;
init)
  cmd_init "$@"
  ;;
config)
  cmd_config "$@"
  ;;
update)
  cmd_update "$@"
  ;;
edit)
  cmd_edit "$@"
  ;;
host)
  cmd_host "$@"
  ;;
tool)
  cmd_tool "$@"
  ;;
script)
  cmd_script "$@"
  ;;
*)
  if [ -n "$command" ]; then
    err "dev: unknown command '$command'"
    log ""
  fi
  usage
  exit 1
  ;;
esac
